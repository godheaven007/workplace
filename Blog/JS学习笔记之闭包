看了网上很多介绍闭包的文章，始终无法明白`闭包`TMD到底是什么？直到下面2篇文章，解决了我的疑惑，在此，先上链接：
1.  [How do JavaScript closures work?](https://stackoverflow.com/questions/111102/how-do-javascript-closures-work)
2. [JS 中的闭包是什么？](https://zhuanlan.zhihu.com/p/22486908)

## 闭包是什么？它能帮我们解决什么问题？
在回答上面的问题之前，先扯点其他的废话！早在`ES6`之前，JS并不存在块级作用域(这有别于`Java`、`C++`等传统面向对象语言）,举个通俗的例子：
```javascript
for(var i = 0; i < 5; i++) {
}
console.log(i);    // 循环结束，外部可以访问变量i的值，输出5
```
但是，有一种情况例外,那就是`函数`,同样上例子：
```
function demo() {
  var local = 100;
  // TODO...
}
```
很显然，我们在外部是无法访问函数内部的变量`local`的。那如果说，我们就是想访问函数内部的某个变量，是否有方案可行呢？

答案就是利用JS的`作用域链实现`。先对作用域链简单总结一下：
- 子执行环境可以访问父执行环境中的变量。若当前执行环境不存在某个变量，就会逐级向上面的父执行环境查找，找到，则停止向上搜索;否则，返回`undefined`。
- 外部执行环境无法访问其子执行环境中的变量。

既然内部函数可以访问外部函数的变量，那我们就可以在函数`demo`内部定义一个函数，返回该变量，并将整个函数返回就可以达到我们的目的了。（说的不是很清楚，上代码）
```
function demo() {
  var local = 100;
  return function() {
    return local;
  }
}
var fn = demo();
var result = fn();
// result = 100
```
是不是So Easy！！！扯了这么多废话，终于到我们的正题了！其实，我们在不知不觉中已经构建了一个闭包。

对于`闭包`的定义，并没有一个统一说法。在我看来，**闭包就是一种机制，它可以用来访问函数内部的局部变量，并且可以持久拥有它！**

`访问函数内部的局部变量`我们上面介绍过了，`持久拥有`是啥玩意？是不是觉得很抽象？！那让我们一起分析一下上面的代码。

通常，调用一个函数，当调用完后，其执行环境就会被**销毁**,其内部的局部变量等（活动对象）也会一起被浏览器的垃圾回收机制回收。但是，函数`fn`所指向的匿名函数中(执行环境)并没有变量`local`,它取的是父执行环境中的`local`，导致它无法被释放，一直被保存在内存中。
也就是上面所说的**持久保存**。

## 应用
1. 暂存数据（上面所提）
2. 模拟私有变量
```
var Car = (function() {
    var speed = 0;
    return {
        setSpeed: function(num) {
            speed = num;
        },
        getSpeed: function() {
            return speed;
        }
    }
})();
```

## 总结
> 编程界崇尚以简洁优雅为美，很多时候如果你觉得一个概念很复杂，那么很可能是你理解错了。

> If everything seems completely unclear then the best thing to do is to play with the examples. 

好啦，这就是我现阶段对于闭包的理解，有可能理解的还不够深刻，有问题欢迎各位拍砖指正！
